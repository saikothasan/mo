import { neon } from "@neondatabase/serverless"
import { z } from "zod"
import type { TelegramUpdate, InlineKeyboardMarkup, User, Question } from "./types" // Assuming TelegramUpdate is defined in a separate file
import type { ExecutionContext } from "@cloudflare/workers-types" // Import ExecutionContext

// Define the environment variables expected by the worker
interface Env {
  TELEGRAM_BOT_TOKEN: string
  AI: any // Cloudflare Workers AI binding
  DATABASE_URL: string // Neon Database URL
}

// Schema for the IQ question generated by the AI
const iqQuestionSchema = z.object({
  question: z.string().describe("The IQ question itself."),
  answer: z.string().describe("The correct answer to the IQ question."),
  explanation: z.string().describe("A brief explanation of the answer."),
})

// Supported IQ question categories
const IQ_CATEGORIES = ["General", "Logical", "Spatial", "Verbal", "Numerical"]

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    if (request.method !== "POST") {
      return new Response("This is a Telegram bot webhook. Send POST requests.", { status: 405 })
    }

    const url = new URL(request.url)
    if (url.pathname === "/webhook") {
      try {
        const update: TelegramUpdate = await request.json()

        let chatId: number
        let messageText: string | undefined
        let callbackData: string | undefined

        if (update.message) {
          chatId = update.message.chat.id
          messageText = update.message.text
        } else if (update.callback_query) {
          chatId = update.callback_query.from.id
          callbackData = update.callback_query.data
          // Acknowledge the callback query to remove the loading state on the button
          await this.answerCallbackQuery(update.callback_query.id, env)
        } else {
          return new Response("No message or callback query in update", { status: 200 })
        }

        const sql = neon(env.DATABASE_URL)

        // Ensure user exists in DB
        await sql`
          INSERT INTO users (chat_id)
          VALUES (${chatId.toString()})
          ON CONFLICT (chat_id) DO NOTHING;
        `

        if (callbackData) {
          await this.handleCallbackQuery(chatId, callbackData, env, sql)
        } else if (messageText) {
          if (messageText.startsWith("/start")) {
            await this.handleStart(chatId, env)
          } else if (messageText.startsWith("/new_question")) {
            await this.handleNewQuestion(chatId, env, sql)
          } else if (messageText.startsWith("/answer ")) {
            const userAnswer = messageText.substring("/answer ".length).trim()
            await this.handleAnswer(chatId, userAnswer, env, sql)
          } else if (messageText.startsWith("/score")) {
            await this.handleScore(chatId, env, sql)
          } else if (messageText.startsWith("/leaderboard")) {
            await this.handleLeaderboard(chatId, env, sql)
          } else if (messageText.startsWith("/categories")) {
            await this.handleCategories(chatId, env)
          } else {
            await this.sendMessage(
              chatId,
              "Unknown command. Use the buttons or type /start, /new_question, /answer <your_answer>, /score, /leaderboard, /categories.",
              env,
            )
          }
        }

        return new Response("OK")
      } catch (error) {
        console.error("Error processing update:", error)
        return new Response("Error processing update", { status: 500 })
      }
    } else {
      return new Response("Not Found", { status: 404 })
    }
  },

  async sendMessage(chatId: number, text: string, env: Env, replyMarkup?: InlineKeyboardMarkup): Promise<void> {
    const telegramApiUrl = `https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`
    const body: any = {
      chat_id: chatId,
      text: text,
      parse_mode: "Markdown",
    }
    if (replyMarkup) {
      body.reply_markup = replyMarkup
    }
    await fetch(telegramApiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    })
  },

  async answerCallbackQuery(callbackQueryId: string, env: Env): Promise<void> {
    const telegramApiUrl = `https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/answerCallbackQuery`
    await fetch(telegramApiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ callback_query_id: callbackQueryId }),
    })
  },

  async getUser(chatId: number, sql: ReturnType<typeof neon>): Promise<User | null> {
    const [user] = await sql<User[]>`SELECT * FROM users WHERE chat_id = ${chatId.toString()};`
    return user || null
  },

  async handleCallbackQuery(
    chatId: number,
    callbackData: string,
    env: Env,
    sql: ReturnType<typeof neon>,
  ): Promise<void> {
    if (callbackData.startsWith("category_")) {
      const category = callbackData.substring("category_".length)
      if (IQ_CATEGORIES.includes(category)) {
        await sql`
          UPDATE users
          SET selected_category = ${category}
          WHERE chat_id = ${chatId.toString()};
        `
        await this.sendMessage(
          chatId,
          `Category set to *${category}*. Use "üß† New Question" to get a question in this category.`,
          env,
        )
      } else {
        await this.sendMessage(chatId, "Invalid category selected.", env)
      }
    } else if (callbackData === "new_question_btn") {
      await this.handleNewQuestion(chatId, env, sql)
    } else if (callbackData === "score_btn") {
      await this.handleScore(chatId, env, sql)
    } else if (callbackData === "leaderboard_btn") {
      await this.handleLeaderboard(chatId, env, sql)
    } else if (callbackData === "categories_btn") {
      await this.handleCategories(chatId, env)
    } else {
      await this.sendMessage(chatId, "Unknown action.", env)
    }
  },

  async handleStart(chatId: number, env: Env): Promise<void> {
    const replyMarkup: InlineKeyboardMarkup = {
      inline_keyboard: [
        [{ text: "üß† New Question", callback_data: "new_question_btn" }],
        [{ text: "üìö Categories", callback_data: "categories_btn" }],
        [{ text: "üèÜ My Score", callback_data: "score_btn" }],
        [{ text: "üìä Leaderboard", callback_data: "leaderboard_btn" }],
      ],
    }

    await this.sendMessage(
      chatId,
      "Welcome to the *Professional IQ Master Bot*! üß†\n\n" +
        "I can generate IQ-style questions for you. Test your logical and problem-solving skills!\n\n" +
        "Use the buttons below or type commands:\n" +
        "‚Ä¢ `/new_question` - Get a new IQ question.\n" +
        "‚Ä¢ `/answer <your_answer>` - Submit your answer to the current question.\n" +
        "‚Ä¢ `/score` - Check your current score.\n" +
        "‚Ä¢ `/leaderboard` - See top players.\n" +
        "‚Ä¢ `/categories` - Choose a question category.",
      env,
      replyMarkup,
    )
  },

  async handleCategories(chatId: number, env: Env): Promise<void> {
    const categoryButtons = IQ_CATEGORIES.map((cat) => ({
      text: cat,
      callback_data: `category_${cat}`,
    }))

    const replyMarkup: InlineKeyboardMarkup = {
      inline_keyboard: [categoryButtons.slice(0, 3), categoryButtons.slice(3)], // Two rows of buttons
    }

    await this.sendMessage(chatId, "Choose a question category:", env, replyMarkup)
  },

  async handleNewQuestion(chatId: number, env: Env, sql: ReturnType<typeof neon>): Promise<void> {
    await this.sendMessage(chatId, "Generating a new IQ question...", env)

    try {
      const user = await this.getUser(chatId, sql)
      const category = user?.selected_category || "General"

      // Direct call to Cloudflare Workers AI binding
      const aiResponse = await env.AI.run(
        "@cf/meta/llama-3.1-8b-instruct", // Using a model that supports JSON output [^1]
        {
          messages: [
            {
              role: "system",
              content:
                "You are an expert IQ question generator. Your task is to create challenging IQ questions and provide the correct answer and a brief explanation in JSON format.",
            },
            {
              role: "user",
              content: `Generate a challenging, professional-level IQ question in the category "${category}". The question should be concise and have a clear, single correct answer. Provide the question, the correct answer, and a brief explanation. Output the response as a JSON object with the following keys: "question", "answer", "explanation".`,
            },
          ],
          response_format: { type: "json_object" }, // Ensures JSON output
        },
      )

      // The AI binding returns the parsed JSON object directly in the 'response' field
      const { question, answer, explanation } = iqQuestionSchema.parse(aiResponse.response)

      // Store the question in the database
      const [newQuestion] = await sql<Question[]>`
        INSERT INTO questions (question_text, correct_answer, explanation, category)
        VALUES (${question}, ${answer}, ${explanation}, ${category})
        RETURNING id;
      `

      // Update user's current question
      await sql`
        UPDATE users
        SET current_question_id = ${newQuestion.id}
        WHERE chat_id = ${chatId.toString()};
      `

      await this.sendMessage(
        chatId,
        `*New IQ Question (${category}):*\n\n${question}\n\nTo answer, use: \`/answer <your_answer>\``,
        env,
      )
    } catch (error) {
      console.error("Error generating question:", error)
      await this.sendMessage(chatId, "Sorry, I couldn't generate a question right now. Please try again later.", env)
    }
  },

  async handleAnswer(chatId: number, userAnswer: string, env: Env, sql: ReturnType<typeof neon>): Promise<void> {
    const user = await this.getUser(chatId, sql)

    if (!user || !user.current_question_id) {
      await this.sendMessage(chatId, 'You don\'t have an active question. Use "üß† New Question" to get one.', env)
      return
    }

    const [question] = await sql<Question[]>`
      SELECT correct_answer, explanation FROM questions WHERE id = ${user.current_question_id};
    `

    if (!question) {
      await this.sendMessage(chatId, "The current question could not be found. Please get a new one.", env)
      await sql`UPDATE users SET current_question_id = NULL WHERE chat_id = ${chatId.toString()};`
      return
    }

    const correctAnswer = question.correct_answer.toLowerCase().trim()
    const submittedAnswer = userAnswer.toLowerCase().trim()

    let message = ""
    let newScore = user.score

    if (submittedAnswer === correctAnswer) {
      newScore += 1
      message = `*Correct!* üéâ Your score is now ${newScore.toFixed(2)}.`
    } else {
      newScore -= 0.5
      message = `*Incorrect.* üòî The correct answer was: *${question.correct_answer}*\n\n*Explanation:*\n${question.explanation}\n\nYour score is now ${newScore.toFixed(2)}.`
    }

    await sql`
      UPDATE users
      SET score = ${newScore}, current_question_id = NULL
      WHERE chat_id = ${chatId.toString()};
    `
    await this.sendMessage(chatId, message, env)
  },

  async handleScore(chatId: number, env: Env, sql: ReturnType<typeof neon>): Promise<void> {
    const user = await this.getUser(chatId, sql)
    const score = user?.score ?? 0
    await this.sendMessage(chatId, `Your current IQ Master score is: *${score.toFixed(2)}*`, env)
  },

  async handleLeaderboard(chatId: number, env: Env, sql: ReturnType<typeof neon>): Promise<void> {
    const topUsers = await sql<User[]>`
      SELECT chat_id, score FROM users
      ORDER BY score DESC
      LIMIT 10;
    `

    let leaderboardText = "*üìä Top 10 IQ Masters:*\n\n"
    if (topUsers.length === 0) {
      leaderboardText += "No scores yet. Be the first to play!"
    } else {
      topUsers.forEach((u, index) => {
        // For a real bot, you'd want to store usernames or allow users to set a display name
        // For now, we'll use a generic "Player X" or their chat_id
        leaderboardText += `${index + 1}. Player ${u.chat_id.substring(0, 4)}...: *${u.score.toFixed(2)}*\n`
      })
    }
    await this.sendMessage(chatId, leaderboardText, env)
  },
}
