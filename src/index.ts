import { createWorkersAI } from "workers-ai-provider"
import { generateObject } from "ai"
import { z } from "zod"
import type { TelegramUpdate } from "./types" // Assuming TelegramUpdate is defined in a separate file
import type { ExecutionContext } from "@cloudflare/workers-types" // Import ExecutionContext

// Define the environment variables expected by the worker
interface Env {
  TELEGRAM_BOT_TOKEN: string
  AI: any // Cloudflare Workers AI binding
  IQ_KV: any // Cloudflare KV binding
}

// Schema for the IQ question generated by the AI
const iqQuestionSchema = z.object({
  question: z.string().describe("The IQ question itself."),
  answer: z.string().describe("The correct answer to the IQ question."),
  explanation: z.string().describe("A brief explanation of the answer."),
})

// Schema for user state stored in KV
const userStateSchema = z.object({
  currentQuestion: z.string(),
  correctAnswer: z.string(),
  explanation: z.string(),
  score: z.number().default(0),
})

type UserState = z.infer<typeof userStateSchema>

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    if (request.method !== "POST") {
      return new Response("This is a Telegram bot webhook. Send POST requests.", { status: 405 })
    }

    const url = new URL(request.url)
    if (url.pathname === "/webhook") {
      try {
        const update: TelegramUpdate = await request.json()
        if (!update.message) {
          return new Response("No message in update", { status: 200 })
        }

        const chatId = update.message.chat.id
        const messageText = update.message.text

        if (!messageText) {
          await this.sendMessage(chatId, "I can only process text messages.", env)
          return new Response("OK")
        }

        if (messageText.startsWith("/start")) {
          await this.handleStart(chatId, env)
        } else if (messageText.startsWith("/new_question")) {
          await this.handleNewQuestion(chatId, env)
        } else if (messageText.startsWith("/answer ")) {
          const userAnswer = messageText.substring("/answer ".length).trim()
          await this.handleAnswer(chatId, userAnswer, env)
        } else if (messageText.startsWith("/score")) {
          await this.handleScore(chatId, env)
        } else {
          await this.sendMessage(
            chatId,
            "Unknown command. Use /start, /new_question, /answer <your_answer>, or /score.",
            env,
          )
        }

        return new Response("OK")
      } catch (error) {
        console.error("Error processing update:", error)
        return new Response("Error processing update", { status: 500 })
      }
    } else {
      return new Response("Not Found", { status: 404 })
    }
  },

  async sendMessage(chatId: number, text: string, env: Env): Promise<void> {
    const telegramApiUrl = `https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`
    await fetch(telegramApiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ chat_id: chatId, text: text, parse_mode: "Markdown" }),
    })
  },

  async getUserState(chatId: number, env: Env): Promise<UserState | null> {
    const state = await env.IQ_KV.get(chatId.toString())
    if (state) {
      return userStateSchema.parse(JSON.parse(state))
    }
    return null
  },

  async setUserState(chatId: number, state: UserState, env: Env): Promise<void> {
    await env.IQ_KV.put(chatId.toString(), JSON.stringify(state))
  },

  async handleStart(chatId: number, env: Env): Promise<void> {
    await this.sendMessage(
      chatId,
      "Welcome to the *Professional IQ Master Bot*! ðŸ§ \n\n" +
        "I can generate IQ-style questions for you. Test your logical and problem-solving skills!\n\n" +
        "Commands:\n" +
        "â€¢ `/new_question` - Get a new IQ question.\n" +
        "â€¢ `/answer <your_answer>` - Submit your answer to the current question.\n" +
        "â€¢ `/score` - Check your current score.",
      env,
    )
  },

  async handleNewQuestion(chatId: number, env: Env): Promise<void> {
    await this.sendMessage(chatId, "Generating a new IQ question...", env)

    try {
      const workersai = createWorkersAI({ binding: env.AI })
      const model = workersai("@cf/meta/llama-3.1-8b-instruct") // Using a model that supports JSON output [^1]

      const { object } = await generateObject({
        model: model,
        prompt:
          "Generate a challenging, professional-level IQ question. The question should be concise and have a clear, single correct answer. Provide the question, the correct answer, and a brief explanation.",
        schema: iqQuestionSchema,
      })

      const { question, answer, explanation } = object

      // Store the question and answer in KV for the user
      const currentState = (await this.getUserState(chatId, env)) || { score: 0 }
      await this.setUserState(
        chatId,
        {
          ...currentState,
          currentQuestion: question,
          correctAnswer: answer,
          explanation: explanation,
        },
        env,
      )

      await this.sendMessage(
        chatId,
        `*New IQ Question:*\n\n${question}\n\nTo answer, use: \`/answer <your_answer>\``,
        env,
      )
    } catch (error: any) {
      // Explicitly type error as 'any' for broader logging
      console.error("Error generating question:", error)
      // Attempt to log more specific error details if available
      if (error.cause) {
        console.error("Error cause:", error.cause)
      }
      if (error.message) {
        console.error("Error message:", error.message)
      }
      if (error.response) {
        console.error("Error response status:", error.response.status)
        console.error("Error response body:", await error.response.text())
      }
      await this.sendMessage(chatId, "Sorry, I couldn't generate a question right now. Please try again later.", env)
    }
  },

  async handleAnswer(chatId: number, userAnswer: string, env: Env): Promise<void> {
    const userState = await this.getUserState(chatId, env)

    if (!userState || !userState.currentQuestion) {
      await this.sendMessage(chatId, "You don't have an active question. Use `/new_question` to get one.", env)
      return
    }

    const correctAnswer = userState.correctAnswer.toLowerCase().trim()
    const submittedAnswer = userAnswer.toLowerCase().trim()

    if (submittedAnswer === correctAnswer) {
      const newScore = (userState.score || 0) + 1
      await this.setUserState(
        chatId,
        { ...userState, score: newScore, currentQuestion: "", correctAnswer: "", explanation: "" },
        env,
      )
      await this.sendMessage(chatId, `*Correct!* ðŸŽ‰ Your score is now ${newScore}.`, env)
    } else {
      const newScore = (userState.score || 0) - 0.5 // Deduct half a point for incorrect answer
      await this.setUserState(
        chatId,
        { ...userState, score: newScore, currentQuestion: "", correctAnswer: "", explanation: "" },
        env,
      )
      await this.sendMessage(
        chatId,
        `*Incorrect.* ðŸ˜” The correct answer was: *${userState.correctAnswer}*\n\n*Explanation:*\n${userState.explanation}\n\nYour score is now ${newScore}.`,
        env,
      )
    }
  },

  async handleScore(chatId: number, env: Env): Promise<void> {
    const userState = await this.getUserState(chatId, env)
    const score = userState?.score ?? 0
    await this.sendMessage(chatId, `Your current IQ Master score is: *${score}*`, env)
  },
}
