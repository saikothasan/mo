import { createWorkersAI } from "workers-ai-provider"
import { generateObject } from "ai"
import { z } from "zod"
import { neon, type NeonQueryFunction } from "@neondatabase/serverless"
import type { TelegramUpdate, InlineKeyboardMarkup, User, Question } from "./types"
import type { ExecutionContext } from "@cloudflare/workers-types"

// Define the environment variables expected by the worker
interface Env {
  TELEGRAM_BOT_TOKEN: string
  AI: any // Cloudflare Workers AI binding
  DATABASE_URL: string // Neon Database URL
}

// Schema for the IQ question generated by the AI
const iqQuestionSchema = z.object({
  question: z.string().describe("The IQ question itself."),
  answer: z.string().describe("The correct answer to the IQ question."),
  explanation: z.string().describe("A brief explanation of the answer."),
  category: z.string().describe("The category of the IQ question (e.g., Logical Reasoning, Numerical Sequence)."),
})

// Predefined categories for the bot
const IQ_CATEGORIES = [
  "Logical Reasoning",
  "Numerical Sequence",
  "Spatial Awareness",
  "Verbal Analogy",
  "General", // Default category
]

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    if (request.method !== "POST") {
      return new Response("This is a Telegram bot webhook. Send POST requests.", { status: 405 })
    }

    const url = new URL(request.url)
    if (url.pathname === "/webhook") {
      try {
        const update: TelegramUpdate = await request.json()

        // Initialize Neon DB client
        const sql: NeonQueryFunction<false, false> = neon(env.DATABASE_URL)

        if (update.message) {
          await this.handleMessage(update.message.chat.id, update.message.text, env, sql)
        } else if (update.callback_query) {
          await this.handleCallbackQuery(update.callback_query.from.id, update.callback_query.data, env, sql)
        } else {
          return new Response("No message or callback query in update", { status: 200 })
        }

        return new Response("OK")
      } catch (error) {
        console.error("Error processing update:", error)
        return new Response("Error processing update", { status: 500 })
      }
    } else {
      return new Response("Not Found", { status: 404 })
    }
  },

  async sendMessage(chatId: number, text: string, env: Env, reply_markup?: InlineKeyboardMarkup): Promise<void> {
    const telegramApiUrl = `https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`
    const body: any = { chat_id: chatId, text: text, parse_mode: "Markdown" }
    if (reply_markup) {
      body.reply_markup = reply_markup
    }
    await fetch(telegramApiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    })
  },

  async getUser(chatId: number, sql: NeonQueryFunction<false, false>): Promise<User | null> {
    const users = await sql<User[]>`SELECT * FROM users WHERE chat_id = ${chatId.toString()}`
    return users.length > 0 ? users[0] : null
  },

  async ensureUserExists(chatId: number, sql: NeonQueryFunction<false, false>): Promise<User> {
    let user = await this.getUser(chatId, sql)
    if (!user) {
      const newUsers = await sql<User[]>`
        INSERT INTO users (chat_id) VALUES (${chatId.toString()})
        ON CONFLICT (chat_id) DO NOTHING
        RETURNING *
      `
      user = newUsers[0] || (await this.getUser(chatId, sql)) // Re-fetch if conflict occurred but no return
    }
    return user!
  },

  async handleMessage(
    chatId: number,
    messageText: string | undefined,
    env: Env,
    sql: NeonQueryFunction<false, false>,
  ): Promise<void> {
    if (!messageText) {
      await this.sendMessage(chatId, "I can only process text messages.", env)
      return
    }

    await this.ensureUserExists(chatId, sql) // Ensure user exists before processing commands

    if (messageText.startsWith("/start")) {
      await this.handleStart(chatId, env)
    } else if (messageText.startsWith("/new_question")) {
      await this.handleNewQuestion(chatId, env, sql)
    } else if (messageText.startsWith("/answer ")) {
      const userAnswer = messageText.substring("/answer ".length).trim()
      await this.handleAnswer(chatId, userAnswer, env, sql)
    } else if (messageText.startsWith("/score")) {
      await this.handleScore(chatId, env, sql)
    } else if (messageText.startsWith("/category")) {
      await this.handleCategorySelectionPrompt(chatId, env)
    } else if (messageText.startsWith("/leaderboard")) {
      await this.handleLeaderboard(chatId, env, sql)
    } else {
      await this.sendMessage(
        chatId,
        "Unknown command. Use the buttons or type:\n" +
          "‚Ä¢ `/new_question`\n" +
          "‚Ä¢ `/answer <your_answer>`\n" +
          "‚Ä¢ `/score`\n" +
          "‚Ä¢ `/category`\n" +
          "‚Ä¢ `/leaderboard`",
        env,
      )
    }
  },

  async handleCallbackQuery(
    chatId: number,
    data: string | undefined,
    env: Env,
    sql: NeonQueryFunction<false, false>,
  ): Promise<void> {
    if (!data) return

    await this.ensureUserExists(chatId, sql) // Ensure user exists

    if (data === "new_question") {
      await this.handleNewQuestion(chatId, env, sql)
    } else if (data === "score") {
      await this.handleScore(chatId, env, sql)
    } else if (data === "leaderboard") {
      await this.handleLeaderboard(chatId, env, sql)
    } else if (data === "categories") {
      await this.handleCategorySelectionPrompt(chatId, env)
    } else if (data.startsWith("set_category:")) {
      const category = data.substring("set_category:".length)
      await this.handleSetCategory(chatId, category, env, sql)
    } else {
      await this.sendMessage(chatId, "Unknown action.", env)
    }
  },

  async handleStart(chatId: number, env: Env): Promise<void> {
    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [{ text: "üß† New Question", callback_data: "new_question" }],
        [{ text: "üìö Categories", callback_data: "categories" }],
        [
          { text: "üèÜ My Score", callback_data: "score" },
          { text: "üìä Leaderboard", callback_data: "leaderboard" },
        ],
      ],
    }
    await this.sendMessage(
      chatId,
      "Welcome to the *Professional IQ Master Bot*! üß†\n\n" +
        "I can generate IQ-style questions for you. Test your logical and problem-solving skills!\n\n" +
        "Use the buttons below or type commands.",
      env,
      keyboard,
    )
  },

  async handleCategorySelectionPrompt(chatId: number, env: Env): Promise<void> {
    const categoryButtons = IQ_CATEGORIES.map((cat) => ({
      text: cat,
      callback_data: `set_category:${cat}`,
    }))

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [categoryButtons.slice(0, 2), categoryButtons.slice(2)], // Arrange into rows
    }

    await this.sendMessage(chatId, "Please choose a question category:", env, keyboard)
  },

  async handleSetCategory(
    chatId: number,
    category: string,
    env: Env,
    sql: NeonQueryFunction<false, false>,
  ): Promise<void> {
    if (!IQ_CATEGORIES.includes(category)) {
      await this.sendMessage(chatId, "Invalid category selected.", env)
      return
    }
    await sql`UPDATE users SET selected_category = ${category} WHERE chat_id = ${chatId.toString()}`
    await this.sendMessage(chatId, `Your question category has been set to *${category}*.`, env)
    await this.handleNewQuestion(chatId, env, sql) // Offer a new question in the selected category
  },

  async handleNewQuestion(chatId: number, env: Env, sql: NeonQueryFunction<false, false>): Promise<void> {
    await this.sendMessage(chatId, "Generating a new IQ question...", env)

    try {
      const workersai = createWorkersAI({ binding: env.AI })
      const model = workersai("@cf/meta/llama-3.1-8b-instruct") // Using a model that supports JSON output [^1]

      const user = await this.getUser(chatId, sql)
      const selectedCategory = user?.selected_category || "General"

      const { object } = await generateObject({
        model: model,
        prompt:
          `Generate a challenging, professional-level IQ question in the category of "${selectedCategory}". ` +
          "The question should be concise and have a clear, single correct answer. " +
          "Provide the question, the correct answer, a brief explanation, and confirm its category.",
        schema: iqQuestionSchema,
      })

      const { question, answer, explanation, category } = object

      // Insert the new question into the database
      const insertedQuestions = await sql<Question[]>`
        INSERT INTO questions (question_text, correct_answer, explanation, category)
        VALUES (${question}, ${answer}, ${explanation}, ${category})
        RETURNING id
      `
      const questionId = insertedQuestions[0].id

      // Update user's current question ID
      await sql`UPDATE users SET current_question_id = ${questionId} WHERE chat_id = ${chatId.toString()}`

      const keyboard: InlineKeyboardMarkup = {
        inline_keyboard: [
          [{ text: "Next Question", callback_data: "new_question" }],
          [
            { text: "üèÜ My Score", callback_data: "score" },
            { text: "üìä Leaderboard", callback_data: "leaderboard" },
          ],
        ],
      }

      await this.sendMessage(
        chatId,
        `*New IQ Question (${category}):*\n\n${question}\n\nTo answer, use: \`/answer <your_answer>\``,
        env,
        keyboard,
      )
    } catch (error) {
      console.error("Error generating question:", error)
      await this.sendMessage(chatId, "Sorry, I couldn't generate a question right now. Please try again later.", env)
    }
  },

  async handleAnswer(
    chatId: number,
    userAnswer: string,
    env: Env,
    sql: NeonQueryFunction<false, false>,
  ): Promise<void> {
    const user = await this.getUser(chatId, sql)

    if (!user || !user.current_question_id) {
      await this.sendMessage(chatId, "You don't have an active question. Use `/new_question` to get one.", env)
      return
    }

    const questions = await sql<Question[]>`SELECT * FROM questions WHERE id = ${user.current_question_id}`
    const currentQuestion = questions.length > 0 ? questions[0] : null

    if (!currentQuestion) {
      await this.sendMessage(chatId, "The current question could not be found. Please get a new one.", env)
      await sql`UPDATE users SET current_question_id = NULL WHERE chat_id = ${chatId.toString()}`
      return
    }

    const correctAnswer = currentQuestion.correct_answer.toLowerCase().trim()
    const submittedAnswer = userAnswer.toLowerCase().trim()

    let feedbackMessage: string
    let newScore = user.score

    if (submittedAnswer === correctAnswer) {
      newScore = Number.parseFloat((newScore + 1).toFixed(2)) // Add 1 point
      feedbackMessage = `*Correct!* üéâ Your score is now ${newScore}.`
    } else {
      newScore = Number.parseFloat((newScore - 0.5).toFixed(2)) // Deduct 0.5 points
      feedbackMessage = `*Incorrect.* üòî The correct answer was: *${currentQuestion.correct_answer}*\n\n*Explanation:*\n${currentQuestion.explanation}\n\nYour score is now ${newScore}.`
    }

    // Update user's score and clear current question
    await sql`
      UPDATE users
      SET score = ${newScore}, current_question_id = NULL
      WHERE chat_id = ${chatId.toString()}
    `

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [{ text: "üß† New Question", callback_data: "new_question" }],
        [
          { text: "üèÜ My Score", callback_data: "score" },
          { text: "üìä Leaderboard", callback_data: "leaderboard" },
        ],
      ],
    }

    await this.sendMessage(chatId, feedbackMessage, env, keyboard)
  },

  async handleScore(chatId: number, env: Env, sql: NeonQueryFunction<false, false>): Promise<void> {
    const user = await this.getUser(chatId, sql)
    const score = user?.score ?? 0.0
    await this.sendMessage(chatId, `Your current IQ Master score is: *${score.toFixed(2)}*`, env)
  },

  async handleLeaderboard(chatId: number, env: Env, sql: NeonQueryFunction<false, false>): Promise<void> {
    const topUsers = await sql<User[]>`
      SELECT chat_id, score
      FROM users
      ORDER BY score DESC
      LIMIT 10
    `

    if (topUsers.length === 0) {
      await this.sendMessage(chatId, "The leaderboard is empty! Be the first to score!", env)
      return
    }

    let leaderboardText = "*üèÜ IQ Master Leaderboard üèÜ*\n\n"
    topUsers.forEach((user, index) => {
      leaderboardText += `${index + 1}. User ${user.chat_id.substring(0, 4)}...: *${user.score.toFixed(2)}*\n`
    })

    await this.sendMessage(chatId, leaderboardText, env)
  },
}
